## 3.2 메모리

#### Memory란?
Memory는 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치, RAM(Random Access Memory)
     
#### 메모리 계층 구조
![image](https://user-images.githubusercontent.com/46198324/199772688-ba8a3b54-4962-42f5-96de-7ac59faf61d6.png)
  - 레지스터 : CPU 안에 있는 작은 메모리로 속도가 가장 빠르지만 용량은 가장 적다.
  - 캐시 : L1, L2 캐시를 말하며 속도가 빠르고 기억 용량이 작다.
  - 주기억장치 : RAM을 말하고 속도가 보통에 기억 용량도 보통이다.
  - 보조기억장치 : HDD, SDD를 말하며 속도가 낮고, 기억 용량이 많다.


계층이 올라갈수록 가격이 비싸지며 용량은 작아지지만 속도는 빨라지는 특징을 가지고 있다.


#### Cache Memory란?
캐시는 데이터를 미리 복사해 놓는 임시 저장소이자 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리이다. 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 한다.


#### 지역성(Locality)
  - 시간 지역성 : 최근 사용한 데이터에 다시 접근하려는 특징
  - 공간 지역성 : 최근 접근한 데이터를 이루는 공간이나 그 가까운 공간에 접근하는 특징

#### 캐시 히트와 캐시 미스
캐시에서 원하는 데이터를 찾았다면 캐시 히트, 원하는 데이터가 캐시에 없다면 주기억장치로 가서 데이터를 찾아오는 것을 캐시 미스라고 한다. 캐시 히트의 경우 CPU 내부 버스를 기반으로 작동하기 때문에 속도가 빠르지만 캐시 미스가 발생하면 데이터를 주기억장치에서 가져오게 될 때 시스템 버스를 기반으로 작동하기 때문에 속도가 느리다.

#### 캐시 매핑 종류
  - 직접 매핑
  - 연관 매핑
  - 집합 연관 매핑 

#### 직접 매핑 
![image](https://user-images.githubusercontent.com/46198324/199774024-594caeaf-2d1d-498f-bef3-deb58b199e80.png)

  - 메인 메모리를 일정한 블록으로 나누고 각 블록을 캐시 메모리의 특정 위치와 매핑하는 방식
  - 캐시 메모리와 주기억장치가 1 : 1로 매핑된다.
  - 회로 구현이 용이하고 간단하다.
  - 캐시 미스가 자주 발생하는 단점이 있다.

#### 연관 매핑 
![image](https://user-images.githubusercontent.com/46198324/199774153-ac22a61c-332e-406b-8ff4-de4e4a3b51bc.png)


  - 캐시 메모리에 데이터를 적재할 시 데이터와 그 데이터의 주기억장치 주소도 함께 저장하는 방식
  - 주기억장치 데이터가 캐시 메모리 어디서나 적재가 가능 (매핑 가능) 
  - 캐시 히트가 높다.
  - 구현 회로가 복잡하고 처리속도가 느리다.

#### 집합 연관 매핑 
![image](https://user-images.githubusercontent.com/46198324/199774174-e3109342-1c50-429c-8a97-e88ee0365888.png)
  - 직접 매핑과 연관 매핑의 조합
  - 캐시 메모리의 한 index 2개 이상의 서로 다른 데이터 블록을 저장하여 하나의 set을 형성한다.
  - 캐시 히트가 높다.
  - 구현회로 및 구조가 복잡하다.

### 웹 브라우저의 캐시

#### 쿠키

  - 만료기한이 있는 키-값 저장소
  - 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일
  - 용량이 작다 (약 4KB)
  - 데이터 변조 가능 및 보안성이 낮아 중요한 정보를 저장하면 안 된다.


  ex) 다시 보지 않음 쿠키 팝업창 , 로그인 자동 완성

#### 로컬 스토리지

  - 로컬 스토리지는 브라우저 창을 닫더라도 데이터 유지된다
  - 서버에 불필요한 데이터를 저장해달라고 요청하지 않아도 된다.
  - 용량이 크다 (10MB, 브라우저마다 차이 존재)
  - HTML5를 지원하지 않는 브라우저의 경우 사용 불가


  ex) 자동 로그인

#### 세션 스토리지
  - 세션 스토리지는 브라우저 창을 닫는 순간 영구적으로 데이터 삭제된다.
  - 용량이 크다 (5MB, 브라우저마다 차이 존재)
  - HTML5를 지원하지 않는 브라우저의 경우 사용 불가


  ex)일회성 로그인, 입력 폼 저장, 비로그인 장바구니
  
### 가상 메모리
![image](https://user-images.githubusercontent.com/46198324/199774525-fdf49304-8c66-4ed8-aef6-5a212fb74d59.png)

  - 가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술로 가상 메모리의 핵심은 필요한 부분만 메모리에 적재하는 것으로 실제 메모리 크기와 상관없이 메모리를 이용할 수 있도록 가상의 메모리 주소를 사용하는 방법이다.
  - CPU에서 당장 수행해야 할 부분만을 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓았다가 다시 필요해지면 메모리에 올라가 있는 부분을 교체하는 방식을 사용한다.


#### 메모리 할당 기법
  - 연속 할당 : 메모리에 연속적으로 공간을 할당하는 것으로 고정 분할 방식과 가변 분할 방식이 있다.
  - 불연속 할당 : 메모리에 연속적으로 할당하지 않고 메모리를 동일한 크기로 나눠 할당하는 방식

### 연속 할당

#### 고정 분할 방식
메모리를 미리 나누어 관리하는 방식으로, 메모리가 미리 나눠져 융통성이 없다. (내부 단편화 발생한다.)

#### 내부 단편화 
![image](https://user-images.githubusercontent.com/46198324/199774933-ab9a02b4-99d4-44f5-8b0a-7cf3aa8b4f3d.png)

메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간

#### 가변 분할 방식
매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. (외부 단편화 발생 가능성이 있다.)

#### 외부 단편화
![image](https://user-images.githubusercontent.com/46198324/199775066-45385414-ce4c-47e2-8629-f628867076a0.png)

메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간


#### 가변 분할 방식 종류

  - 최초 적합 : 가장 먼저 찾는 홀에 바로 할당한다.
  - 최적 적합 : 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다.
  - 최악 적합 : 프로세스의 크기 이상인 공간 중 가장 차이가 큰 홀에 할당한다.

### 불연속 할당
불연속 메모리 할당 기법으로 페이징(paging), 세그멘테이션(segmentation) 있고 두 가지 방식을 혼합한 페이지드 세그멘테이션(paged segmentation) 있다.

 

#### 페이징(paging)

  - 프로세스의 주소 공간을 동일한 크기의 페이지(page) 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식
  - 물리적 메모리에 불연속으로 저장하는 방식

#### 세그멘테이션(segmentation)

  - 논리적인 내용 단위로 프로세스의 메모리 공간을 분리하는 기법
  - 논리적 단위로는 method, function, object,  stack, variables, procedure 등 함수 단위로 나눌 수 있고 C 컴파일러 관점에서는 코드, 전역 변수, 힙, 스택, 표준 C 라이브러리 단위로 구분 지어 나눌 수 있다.

#### 페이지드 세그멘테이션(paged segmentation)

  - 페이지드 세그멘테이션은 세그멘테이션과 페이징의 장점을 취한 방식
  - 세그멘테이션은 가변 분할 방식이라서 코드 영역, 데이터 영역, 스택 영역, 힙 영역을 세그먼트로 나눠서 관리할 수 있다. 때문에 다른 프로세스와 공유하기도 편하고 각 영역에 대한 메모리 접근 보호를 하기 쉽다.
  - 페이징은 고정 분할 방식으로 메모리를 효율적으로 관리할 수 있다.
 

### 페이지 교체 알고리즘

페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이지 부재) 어떤 페이지 프레임을 선택하여 교체할 것인지 결정하는 방법이다.


#### 페이지 교체 알고리즘의 종류

  - OPT(오프라인 알고리즘) : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
  - FIFO : First In First Out
  - LRU (Least Recently Used) : 가장 오랫동안 사용되지 않은 페이지 교체
  - LFU (Least Frequently Used) : 참조 횟수가 가장 작은 페이지 교체
  - MFU (Most Frequently used) : 참조 횟수가 가장 많은 페이지 교체
  - NUR (Not Used Recently) : 최근에 사용하지 않은 페이지 교체

#### LRU (Least Recently Used)

 ![image](https://user-images.githubusercontent.com/46198324/199907445-b24a2adb-763d-41fe-933a-dcd3a5bdb7e1.png)

  - 가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것을 가정한 방식이다. (시간 지역성)
  - 사용된 시간을 알 수 있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거한다.
  - 큐로 구현 가능. 사용한 데이터를 큐에서 제거하여 맨 위로 다시 올리고, 프레임이 모자랄 경우 맨 아래에 있는 데이터를 삭제한다.
  - 프로세스가 주기억장치에 접근할 때마다 참조된 페이지 시간을 기록해야 하므로 오버헤드가 발생한다.

#### LFU (Least Frequently Used)

![image](https://user-images.githubusercontent.com/46198324/199907517-72eb8fc4-6237-46d0-8c0c-188fa6db180a.png)


  - 페이지의 참조 횟수가 가장 낮은 페이지를 교체할 페이지 결정하는 방식이다.
  - 가장 최근에 불러온 페이지가 교체될 가능성이 높다.
  - 구현 방법이 복잡하고 오버헤드가 발생한다.
